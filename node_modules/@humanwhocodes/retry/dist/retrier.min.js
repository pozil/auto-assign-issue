class RetryTask{fn;error;timestamp=Date.now();lastAttempt=this.timestamp;resolve;reject;constructor(t,e,r,s){this.fn=t,this.error=e,this.timestamp=Date.now(),this.lastAttempt=Date.now(),this.resolve=r,this.reject=s}}class Retrier{#t=[];#e;#r;#s;#i;constructor(t,{timeout:e=6e4,maxDelay:r=100}={}){if("function"!=typeof t)throw new Error("Missing function to check errors");this.#i=t,this.#e=e,this.#r=r}retry(t){let e;try{e=t()}catch(t){return Promise.reject(new Error(`Synchronous error: ${t.message}`,{cause:t}))}return e&&"function"==typeof e.then?Promise.resolve(e).catch((e=>{if(!this.#i(e))throw e;return new Promise(((r,s)=>{this.#t.push(new RetryTask(t,e,r,s)),this.#o()}))})):Promise.reject(new Error("Result is not a promise."))}#o(){clearTimeout(this.#s),this.#s=void 0;const t=this.#t.shift();if(t){if(function(t,e){return Date.now()-t.timestamp>e}(t,this.#e))return t.reject(t.error),void this.#o();if(!function(t,e){const r=Date.now()-t.lastAttempt,s=Math.max(t.lastAttempt-t.timestamp,1);return r>=Math.min(1.2*s,e)}(t,this.#r))return this.#t.unshift(t),void(this.#s=setTimeout((()=>this.#o()),0));t.lastAttempt=Date.now(),Promise.resolve(t.fn()).then((e=>t.resolve(e))).catch((e=>{this.#i(e)?(t.lastAttempt=Date.now(),this.#t.push(t)):t.reject(e)})).finally((()=>this.#o()))}}}export{Retrier};
